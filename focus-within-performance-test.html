<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Focus-Within Performance Test</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    .test-container {
      border: 1px solid #ccc;
      padding: 10px;
      margin: 10px 0;
    }
    .controls {
      background: #f5f5f5;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
    }
    .results {
      background: #e8f4f8;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
    }
    .winner {
      color: #0a8a0a;
      font-weight: bold;
    }
    .loser {
      color: #c00;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      margin: 5px;
      border-radius: 4px;
      border: 1px solid #007bff;
      background: #007bff;
      color: white;
    }
    button:hover {
      background: #0056b3;
    }
    input {
      padding: 8px;
      margin: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .nested {
      margin-left: 20px;
      padding-left: 10px;
      border-left: 2px solid #ddd;
    }
    .config {
      display: grid;
      grid-template-columns: 200px 1fr;
      gap: 10px;
      align-items: center;
      margin: 10px 0;
    }
    .focused {
      background-color: #ffffcc;
      outline: 2px solid #007bff;
    }
  </style>
</head>
<body>
  <h1>Focus-Within Performance Test</h1>
  <p>
    This test compares the performance of three methods for checking if a node contains focus:
  </p>
  <ul>
    <li><code>nodeContains(node, document.activeElement)</code> - ShadowDOM-safe contains</li>
    <li><code>node.matches(':focus-within')</code></li>
    <li><code>isFocusWithin(node)</code> - uses <code>node.getRootNode().activeElement</code></li>
  </ul>

  <div class="controls">
    <h2>Configuration</h2>
    <div class="config">
      <label>Depth of nesting:</label>
      <input type="number" id="depth" value="10" min="1" max="20">
    </div>
    <div class="config">
      <label>Containers per level:</label>
      <input type="number" id="containers" value="5" min="1" max="10">
    </div>
    <div class="config">
      <label>Test iterations:</label>
      <input type="number" id="iterations" value="10000" min="100" max="1000000">
    </div>
    <div class="config">
      <label>Warmup runs:</label>
      <input type="number" id="warmup" value="1000" min="0" max="10000">
    </div>
    <button onclick="buildStructure()">Build Test Structure</button>
    <button onclick="runPerformanceTest()">Run Performance Test</button>
  </div>

  <div id="test-structure"></div>

  <div class="results" id="results" style="display: none;">
    <h2>Results</h2>
    <div id="results-content"></div>
  </div>

  <script>
    let testNodes = [];
    let focusedElement = null;

    // Helper function to check if a node is a shadow root
    function isShadowRoot(node) {
      return node && (node instanceof ShadowRoot || node.toString() === '[object ShadowRoot]');
    }

    // Mock for shadowDOM flag (set to true to test shadow DOM mode, false for regular DOM)
    function shadowDOM() {
      return false; // Can be changed to true to test shadow DOM behavior
    }

    // nodeContains function from @react-aria/utils
    function nodeContains(node, otherNode) {
      if (!shadowDOM()) {
        return otherNode && node ? node.contains(otherNode) : false;
      }

      if (!node || !otherNode) {
        return false;
      }

      let currentNode = otherNode;

      while (currentNode !== null) {
        if (currentNode === node) {
          return true;
        }

        if (currentNode.tagName === 'SLOT' && currentNode.assignedSlot) {
          // Element is slotted
          currentNode = currentNode.assignedSlot.parentNode;
        } else if (isShadowRoot(currentNode)) {
          // Element is in shadow root
          currentNode = currentNode.host;
        } else {
          currentNode = currentNode.parentNode;
        }
      }

      return false;
    }


    /**
     * ShadowDOM safe version of document.activeElement.
     */
    const getActiveElement = (doc = document) => {
      if (!shadowDOM()) {
        return doc.activeElement;
      }
      let activeElement = doc.activeElement;

      while (activeElement && 'shadowRoot' in activeElement &&
      activeElement.shadowRoot?.activeElement) {
        activeElement = activeElement.shadowRoot.activeElement;
      }

      return activeElement;
    };

    // isFocusWithin function from @react-aria/utils
    function isFocusWithin(node) {
      // Get the active element within the node's parent shadow root (or the document). Can return null.
      let activeElement = node.getRootNode().activeElement;

      // Check if the active element is within this node. These nodes are within the same shadow root.
      return activeElement && node.contains(activeElement);
    }

    function buildStructure() {
      const depth = parseInt(document.getElementById('depth').value);
      const containersPerLevel = parseInt(document.getElementById('containers').value);
      const container = document.getElementById('test-structure');
      container.innerHTML = '';
      testNodes = [];

      function createNestedStructure(parent, currentDepth, path = '') {
        if (currentDepth === 0) {
          // At the deepest level, create the focused input
          const input = document.createElement('input');
          input.type = 'text';
          input.id = 'focused-input';
          input.placeholder = 'This input will be focused';
          input.className = 'focused';
          parent.appendChild(input);
          focusedElement = input;
          return;
        }

        for (let i = 0; i < containersPerLevel; i++) {
          const div = document.createElement('div');
          div.className = 'test-container nested';
          div.dataset.path = `${path}/${i}`;
          div.innerHTML = `<strong>Level ${depth - currentDepth + 1}, Container ${i + 1}</strong>`;
          parent.appendChild(div);

          // Store every other container for testing (to have a mix of ancestors and non-ancestors)
          if (i % 2 === 0) {
            testNodes.push(div);
          }

          // Only create nested structure in the first container to keep it manageable
          if (i === 0) {
            createNestedStructure(div, currentDepth - 1, `${path}/${i}`);
          } else {
            // Add some dummy content to other containers
            const dummy = document.createElement('div');
            dummy.textContent = 'Sibling container (no focus)';
            div.appendChild(dummy);
          }
        }
      }

      const root = document.createElement('div');
      root.id = 'root-container';
      root.className = 'test-container';
      root.innerHTML = '<h3>Test Structure</h3>';
      container.appendChild(root);
      testNodes.push(root);

      createNestedStructure(root, depth);

      // Focus the input
      setTimeout(() => {
        if (focusedElement) {
          focusedElement.focus();
        }
      }, 100);

      document.getElementById('results').style.display = 'none';
      console.log(`Built structure with ${testNodes.length} test nodes`);
    }

    function runPerformanceTest() {
      if (testNodes.length === 0) {
        alert('Please build the test structure first!');
        return;
      }

      const iterations = parseInt(document.getElementById('iterations').value);
      const warmupRuns = parseInt(document.getElementById('warmup').value);

      console.log(`Running performance test with ${iterations} iterations...`);

      // Warmup runs
      if (warmupRuns > 0) {
        console.log(`Running ${warmupRuns} warmup iterations...`);
        for (let i = 0; i < warmupRuns; i++) {
          testNodes.forEach(node => {
            nodeContains(node, getActiveElement());
            node.matches(':focus-within');
            isFocusWithin(node);
          });
        }
      }

      // Test 1: nodeContains(node, document.activeElement)
      const containsStart = performance.now();
      let containsResults = 0;
      for (let i = 0; i < iterations; i++) {
        testNodes.forEach(node => {
          if (nodeContains(node, getActiveElement())) {
            containsResults++;
          }
        });
      }
      const containsEnd = performance.now();
      const containsTime = containsEnd - containsStart;

      // Test 2: node.matches(':focus-within')
      const matchesStart = performance.now();
      let matchesResults = 0;
      for (let i = 0; i < iterations; i++) {
        testNodes.forEach(node => {
          if (node.matches(':focus-within')) {
            matchesResults++;
          }
        });
      }
      const matchesEnd = performance.now();
      const matchesTime = matchesEnd - matchesStart;

      // Test 3: isFocusWithin(node)
      const isFocusWithinStart = performance.now();
      let isFocusWithinResults = 0;
      for (let i = 0; i < iterations; i++) {
        testNodes.forEach(node => {
          if (isFocusWithin(node)) {
            isFocusWithinResults++;
          }
        });
      }
      const isFocusWithinEnd = performance.now();
      const isFocusWithinTime = isFocusWithinEnd - isFocusWithinStart;

      // Calculate stats
      const totalChecks = iterations * testNodes.length;
      const containsPerOp = containsTime / totalChecks;
      const matchesPerOp = matchesTime / totalChecks;
      const isFocusWithinPerOp = isFocusWithinTime / totalChecks;

      // Display results
      const resultsDiv = document.getElementById('results-content');

      // Find the fastest method
      const times = [
        { name: 'contains', time: containsTime },
        { name: 'matches', time: matchesTime },
        { name: 'isFocusWithin', time: isFocusWithinTime }
      ];
      times.sort((a, b) => a.time - b.time);
      const fastest = times[0].name;

      resultsDiv.innerHTML = `
        <h3>Test Configuration</h3>
        <p>
          • Total checks per method: ${totalChecks.toLocaleString()}<br>
          • Nodes tested: ${testNodes.length}<br>
          • Iterations: ${iterations.toLocaleString()}<br>
          • Positive matches per iteration: ${containsResults / iterations}
        </p>

        <h3>Performance Results</h3>
        <table style="width: 100%; margin: 20px 0;">
          <tr style="border-bottom: 2px solid #333;">
            <th style="text-align: left; padding: 8px;">Method</th>
            <th style="text-align: right; padding: 8px;">Total Time</th>
            <th style="text-align: right; padding: 8px;">Per Check</th>
            <th style="text-align: right; padding: 8px;">Checks/sec</th>
            <th style="text-align: right; padding: 8px;">vs Fastest</th>
          </tr>
          <tr class="${fastest === 'contains' ? 'winner' : 'loser'}">
            <td style="padding: 8px;"><code>nodeContains(node, getActiveElement())</code></td>
            <td style="text-align: right; padding: 8px;">${containsTime.toFixed(2)} ms</td>
            <td style="text-align: right; padding: 8px;">${(containsPerOp * 1000).toFixed(3)} μs</td>
            <td style="text-align: right; padding: 8px;">${(1000 / containsPerOp).toFixed(0).toLocaleString()}</td>
            <td style="text-align: right; padding: 8px;">${fastest === 'contains' ? '—' : (containsTime / times[0].time).toFixed(2) + 'x'}</td>
          </tr>
          <tr class="${fastest === 'matches' ? 'winner' : 'loser'}">
            <td style="padding: 8px;"><code>node.matches(':focus-within')</code></td>
            <td style="text-align: right; padding: 8px;">${matchesTime.toFixed(2)} ms</td>
            <td style="text-align: right; padding: 8px;">${(matchesPerOp * 1000).toFixed(3)} μs</td>
            <td style="text-align: right; padding: 8px;">${(1000 / matchesPerOp).toFixed(0).toLocaleString()}</td>
            <td style="text-align: right; padding: 8px;">${fastest === 'matches' ? '—' : (matchesTime / times[0].time).toFixed(2) + 'x'}</td>
          </tr>
          <tr class="${fastest === 'isFocusWithin' ? 'winner' : 'loser'}">
            <td style="padding: 8px;"><code>isFocusWithin(node)</code> (getRootNode)</td>
            <td style="text-align: right; padding: 8px;">${isFocusWithinTime.toFixed(2)} ms</td>
            <td style="text-align: right; padding: 8px;">${(isFocusWithinPerOp * 1000).toFixed(3)} μs</td>
            <td style="text-align: right; padding: 8px;">${(1000 / isFocusWithinPerOp).toFixed(0).toLocaleString()}</td>
            <td style="text-align: right; padding: 8px;">${fastest === 'isFocusWithin' ? '—' : (isFocusWithinTime / times[0].time).toFixed(2) + 'x'}</td>
          </tr>
        </table>

        <h3>Comparison</h3>
        <p style="font-size: 18px;">
          <span class="winner">✓ ${fastest === 'contains' ? 'nodeContains()' : fastest === 'matches' ? 'matches()' : 'isFocusWithin()'} is the fastest</span>
        </p>
        <p>
          Rankings:<br>
          1st: ${times[0].name} (${times[0].time.toFixed(2)} ms)<br>
          2nd: ${times[1].name} (${times[1].time.toFixed(2)} ms, ${(times[1].time / times[0].time).toFixed(2)}x slower)<br>
          3rd: ${times[2].name} (${times[2].time.toFixed(2)} ms, ${(times[2].time / times[0].time).toFixed(2)}x slower)
        </p>

        <h3>Analysis</h3>
        <p>
          <strong>Method Descriptions:</strong>
          <ul>
            <li><code>nodeContains(node, document.activeElement)</code> - ShadowDOM-safe version that walks the DOM tree including shadow boundaries, slots, and shadow roots</li>
            <li><code>matches(':focus-within')</code> - Uses CSS selector matching to check if the element matches the :focus-within pseudo-class</li>
            <li><code>isFocusWithin(node)</code> - Gets activeElement from getRootNode() (works with shadow roots) then uses nodeContains()</li>
          </ul>
        </p>
        <p>
          <strong>Key Differences:</strong><br>
          The <code>nodeContains</code> function handles shadow DOM scenarios by traversing through shadow boundaries, while
          <code>isFocusWithin</code> is optimized by getting the active element from the correct shadow root first using
          <code>getRootNode().activeElement</code>, which retrieves the active element within the same shadow root,
          before calling <code>nodeContains</code>.
        </p>
        <p>
          <strong>Note:</strong> Performance can vary based on:
          <ul>
            <li>Browser implementation and version</li>
            <li>DOM tree depth and complexity</li>
            <li>CPU and system load</li>
            <li>Whether the node is an ancestor of the focused element</li>
            <li>Presence of shadow DOM</li>
          </ul>
        </p>
      `;

      document.getElementById('results').style.display = 'block';

      console.log('Performance test complete!');
      console.log(`nodeContains(): ${containsTime.toFixed(2)}ms`);
      console.log(`matches(): ${matchesTime.toFixed(2)}ms`);
      console.log(`isFocusWithin(): ${isFocusWithinTime.toFixed(2)}ms`);
      console.log(`Winner: ${fastest}`);
    }

    // Build initial structure on load
    window.addEventListener('load', () => {
      buildStructure();
    });
  </script>
</body>
</html>
