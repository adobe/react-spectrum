import {TableView} from '@react/react-spectrum/TableView';
import {columns, TestDS, renderCell, renderEmptyView} from '../helpers/TableView';
import ListDataSource from '@react/react-spectrum/ListDataSource';

A **TableView** displays a list of content with rows and columns. It supports many advanced features like sorting,
infinite scrolling, drag and drop both into and out of the table, multiple selection, keyboard navigation, and more.
It is designed to scale to collections of any size using a virtual scroller that only renders the currently visible
items into the DOM.

## Example

<TableView
  columns={columns}
  dataSource={new TestDS}
  renderCell={renderCell}
  className="example-tableview" />

```jsx
import {TableView} from '@react/react-spectrum/TableView';

<TableView
  columns={columns}
  dataSource={new MyDataSource}
  renderCell={renderCell} />
```

See below for details about these props.

## Overview

To set up a TableView, a few pieces are required: column definitions to display, a data source to provide the rows to display,
and a `renderCell` function to render the UI for an individual cell.

### Columns

TableView accepts a list of column definitions, which declare various attributes about the columns that should be displayed in the table.
The attributes are as follows:

* `title` - a string to display as the title for the column. You should handle localization of this string into different languages in your app. Required.
* `sortable` - whether the column is sortable by clicking on the column header.
* `divider` - whether the column has a divider to its right.
* `align` - the alignment for items in the column. 'left', 'center', or 'right'.
* `width` - a fixed width for the columns.
* `minWidth` - a minimum width for the column.
* `maxWidth` - a maximum width for the column.

As an example, the columns for the above example table are as follows:

```javascript
let columns = [
  {
    title: 'Active',
    key: 'enabled',
    width: 100,
    announce: false
  },
  {
    title: 'Name',
    key: 'name',
    minWidth: 200,
    sortable: true,
    divider: true
  },
  {
    title: 'Created By',
    key: 'createdBy',
    width: 200,
    sortable: true
  }
];
```

### Data Sources

A data source provides the data for a TableView to display, and responds to user initiated actions such as drag and drop.
Data sources can be shared across multiple types of views that display collections of data, e.g. TableView and a grid or list view.
Data provided by a data source is two dimensional: items are grouped into sections. This can be useful, for example, if you 
want to display headers above a group of items.

There is a base class for data sources that can be used by TableView called [ListDataSource](/classes/ListDataSource), which supports asynchronous
loading of data, infinite scrolling, and sorting. To provide data, implement the `load` method and return the data for
the rows you want to display. If you want to support infinite scrolling, implement the `loadMore` method as well.

```javascript
import ListDataSource from '@react/react-spectrum/ListDataSource';

class MyDataSource extends ListDataSource {
  async load(sortDescriptor) {
    // load some data here
    // If sortDescriptor is provided, then sort the data accordingly.
    return [...];
  }

  async loadMore() {
    // load more data
    return [...];
  }
}
```

These methods support loading data in a single section. If you want to support multiple sections, you should override the
`performLoad` and `performLoadMore` methods instead to perform your own insertion logic to ensure items are grouped into the
correct sections.

When data in the data source changes, perhaps in response to some external event such as a server update, the data source 
should emit events. The table view listens for these events and updates its views as necessary, optionally with an animation. 
There are helper methods as part of the base data source class that you can call to emit these events and update the data.
You can also use transactions to group multiple updates together into a single animation. See the [API docs](/classes/ListDataSource) for details.

### Cell Renderers

The last required piece for a TableView is a `renderCell` prop, which is just a function to render the contents of a cell.
It receives the column definition and the data for the row to render.

```jsx
function renderCell(column, data) {
  return <span>data[column.key]</span>;
}
```

## Sorting

TableView supports sorting data in response to a user clicking on a sortable column header. In order to enable sorting,
you should enable the `sortable` property on your column definition. This allows the user to click on a column, and displays
the sort direction arrow icon in the column header when sorting by that column.

Once this is enabled, you need to respond to sort changes and update the data in the TableView. By default, TableView reloads
the data using the data source's `load` method, to which it passes a sort descriptor. A sort descriptor is an object with 
`column` and `direction` properties. The `column` is a column object as provided to TableView's `columns` prop, and `direction`
is either `TableView.SORT_ASCENDING` or `TableView.SORT_DESCENDING`. You can use this information to make an API call to 
retrieve sorted data, or re-sort the data locally.

If you need to sync the current sorting information with other UIs, you can listen for the `onSortChange` event, which is passed
the sort descriptor object when it changes. You can pass this sort descriptor back into the TableView using the `sortDescriptor`
prop. If you only want to set the initial sort descriptor and not control the component, you can pass the `defaultSortDescriptor`
prop instead.

```jsx
let columns = [
  // ...
  {
    title: 'Date',
    sortable: true
  }
];

<TableView
  {...otherProps}
  columns={columns}
  defaultSortDescriptor={{column: columns[0], direction: TableView.SORT_ASCENDING}}
  onSortChange={(sortDescriptor) => {}} />
```

## Selection

TableView supports multiple selection out of the box, displayed using checkboxes on each row. Selection is enabled by default, 
but you can disable it by setting the `allowsSelection` prop to `false`. If you want to only allow selecting one item at a time,
set `allowsMultipleSelection` to `false`.

To handle selection changes, you can use the `onSelectionChange` prop. This will be passed a list of `IndexPath` objects, which store
the indexes of the items that are currently selected. An `IndexPath` has `section` and `index` properties, which represent the indices 
in the two dimensional array of items provided by the data source.

To set the selection programmatically, provide the `selectedIndexPaths` prop to the TableView. This should be an array of `IndexPath` objects,
like the one passed to `onSelectionChange`.

```jsx
<TableView
  {...otherProps}
  selectedIndexPaths={[...]}
  onSelectionChange={(selectedIndexPaths) => {}} />
```

## Drag and Drop

TableView supports both dragging rows from a table (a drag source), as well as dropping files or other objects into a table (a drop target).
It uses the native HTML5 drag and drop API, so it is easy to integrate with other drag and drop solutions that other components might use.
You can provide custom data to be passed with the drag, which will be received by the drop target, and provide a custom view to be
displayed under the cursor while dragging. Drops into a TableView can be between rows (inserting into a list), onto a row (for example adding 
items into rows representing folders), or onto the entire table body (adding items into the current view). Items can also be optionally
reordered by dragging by enabling the `canReorderItems` prop.

The following example shows how items can be dragged from one TableView to another. Items on the right can also be reordered.

<div style={{display: 'flex', justifyContent: 'space-between'}}>
  <TableView
    columns={[columns[1]]}
    dataSource={new TestDS}
    renderCell={renderCell}
    className="example-tableview"
    canDragItems />
  <TableView
    columns={[columns[1]]}
    dataSource={new TestDS([])}
    renderCell={renderCell}
    className="example-tableview"
    acceptsDrops
    renderEmptyView={renderEmptyView}
    canReorderItems />
</div>

### Drag Sources

To enable dragging items from a TableView, pass the `canDragItems` prop. This is all you need to do to enable basic support for dragging rows.
If you want to customize how the drag and drop works, there are some additional functions you can override.

#### Customizing the drag view

By default, the entire row will be rendered under the cursor while dragging. To customize this, you can provide the `renderDragView` prop
to TableView to render any custom view you want. It is passed a drag target representing the item the user actually clicked and dragged from,
along with the selected index paths for all items that would be dragged.

```jsx
<TableView
  {...otherProps}
  renderDragView={(dragTarget, selectedIndexPaths) => <div>My custom drag view</div>} />
```

#### Customizing the drag data

By default, the selected item objects are serialized to JSON and passed along with the drag to the drop target. This will work
if the only drop targets you want to support are other TableViews or GridViews, but you may want to support a custom data format for your
content that will work across applications and frameworks. You can also provide data in multiple representations, so that many
different receiving applications can handle the drop. To do this, you can override the `prepareDragData` method of your
data source.

```javascript
class MyDataSource extends ListDataSource {
  // ...
  
  prepareDragData(dragTarget, dataTransfer, selectedIndexPaths) {
    // Add plain text representation
    dataTransfer.setData('text/plain', 'some text');

    // Add rich text representation
    dataTransfer.setData('text/html', '<strong>some bold text</strong>');

    // Add custom data
    dataTransfer.setData('my-custom-format', 'some data');
  }
}
```

### Drop Targets

To enable dropping files or other objects in a TableView, pass the `acceptsDrops` prop. This can be a boolean to accept all drops,
or a list of allowed drag types (e.g. `Files`, `text/plain` or your custom format name).

#### Handling drops

By default, TableView will handle drops from other TableViews or GridViews, but you may need to support dropping files or other custom types
of objects. To do this, you need to implement the `itemsForDrop` method on your data source. This method is passed a drop target
and the data transfer object from the drag, and should return items that should be dropped.

Once those items are chosen, they are inserted into the TableView as rows automatically. If you want to do any custom handling,
e.g. uploading dropped files, or performing other custom logic, you can override the `performDrop` method.

```javascript
class MyDataSource extends ListDataSource {
  // ...
  
  itemsForDrop(dropTarget, dataTransfer) {
    // parse your custom format
    return JSON.parse(dataTransfer.getData('my-custom-format'));
  }

  performDrop(dropTarget, dropOperation, items) {
    // custom logic here
  }
}
```

#### Customizing the drop position

Items can be dropped in several different positions over a TableView. They can be inserted between rows, dropped on top of rows
(e.g. uploading into a folder), or dropped on top of the table itself (e.g. uploading into the current folder). To control this behavior,
pass either `"on"` or `"between"` to the `dropPosition` prop.

With `dropPosition="between"`, the dragged items are inserted as rows above the target. This is indicated by a blue line between the rows.
If you drag past the last row in the table into the empty space, the items are inserted at the end.

With `dropPosition="on"`, the dragged items are dropped into the target. This is indicated by highlighting the target row with a blue outline.
If you drag past the last row, the items are dropped into the table as a whole. This is indicated by highlighting the entire table with a 
blue outline.

In order to get more fine grained control over this behavior, e.g. allowing drops on some items but not others, you can override 
the `getDropTarget` method of the data source to override the default target.

The following example shows how you might allow dropping onto folders but not files, e.g. in a file manager. Assuming `dropPosition="on"`
has already been set, the `getDropTarget` method is used to override the target return `null` if it is not a folder.

```javascript
class MyDataSource extends ListDataSource {
  // ...
  
  getDropTarget(target) {
    // Get the row object
    let row = this.sections[target.indexPath.section][target.indexPath.index];

    // If the row is a folder, allow dropping into it.
    if (row.type === 'folder') {
      return target;
    }

    // Otherwise, prevent the drop.
    return null;
  }
}
```

## Accessibility

TableView implements the aria grid design pattern. It handles multiselection, row focusing, and is fully keyboard accessibile out of the box.

## Internationalization

To internationalize a TableView, you should provide localized content as needed, for example column titles and cell data formatting.

### Why doesn't my table render

TableView uses a virtual scroller to enable fast scrolling on large datasets. Because of this, the TableView cannot know how big it should grow (it's contents are potentially infinite in height), so we must tell the TableView how big it should be, and we must do this upfront so it can calculate how many items it can display.
Allocating height to an element far down in the DOM structure can be a bit tricky as most people try to let content determine how much space something takes up. Instead, think about how much height each item on a page should get ahead of time. You can do this easily with [flexbox layouts](https://css-tricks.com/snippets/css/a-guide-to-flexbox/). If you must do it with height: 100%, then make sure all parents also set this. For information on why a 100% div collapses, you can read [this](https://stackoverflow.com/questions/7049875/why-doesnt-height-100-work-to-expand-divs-to-the-screen-height).

If you're curious if you've successfully allocated the space, you can always style your container with a border to make sure it's the right dimensions before you place your TableView. For example, you can do things like [this](https://jsfiddle.net/snowystinger/43mot8xk/22/).

TableView comes with its height already set to 100%, so as long as it has space up front, you should now be good to go.
See [here](https://github.com/adobe/react-spectrum/blob/master/src/TableView/style/index.styl#L21).

[Example source code](https://github.com/adobe/react-spectrum/blob/master/stories/TableView.js)
