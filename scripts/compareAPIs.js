
let fs = require('fs-extra');
let fg = require('fast-glob');
let path = require('path');
let util = require('util');
let chalk = require('chalk');
let yargs = require('yargs');
let Diff = require('diff');

let argv = yargs
  .option('verbose', {alias: 'v', type: 'boolean'})
  .option('organizedBy', {choices: ['type', 'change']})
  .option('rawNames', {type: 'boolean'})
  .option('package', {type: 'string'})
  .option('interface', {type: 'string'})
  .option('isCI', {type: 'boolean'})
  .option('base-api-dir', {type: 'string'})
  .option('branch-api-dir', {type: 'string'})
  .argv;

let allChanged = new Map();

// {'useSliderState' => [ 'SliderStateOptions', 'SliderState' ], ... }
let dependantOnLinks = new Map();
let currentlyProcessing = '';
let depth = 0;
let linksToDiff = new Map();
let linkDiffs = new Map();

let allLinks = new Map();
let visited = new Set();
if (require.main === module) {
  compare().catch(err => {
    console.error(err.stack);
    process.exit(1);
  });
}

// walk up the tree and find the first package.json, then return the name
function findPackageName(filepath) {
  let parts = filepath.split(path.sep);
  for (let i = parts.length - 2; i >= 0; i--) {
    let newPath = parts.slice(0, i).join(path.sep);
    if (fs.exists(path.join(newPath, 'package.json'))) {
      return JSON.parse(fs.readFileSync(path.join(newPath, 'package.json'))).name;
    }
  }
  throw new Error('Could not find package.json for ' + filepath);
}

/**
 * This takes the json files generated by the buildBranchAPI and buildPublishedAPI and
 * reconstructs our interfaces and create a graph of all dependencies between interfaces.
 * From there, we diff the reconstructed interfaces and track all that have changes.
 * We use the graph to communicate what interfaces have changed as a result of a
 * dependency changing.
 * We build up strings of the diffs and make them easy to read in both a github comment
 * as well as the local console.
 */
export async function compare(mockRoot, mockFS, {branchAPIs, publishedAPIs} = {}) {
  if (mockFS) {
    // reset all globals if in testing mode
    fs = mockFS;
    allChanged = new Map();
    dependantOnLinks = new Map();
    depth = 0;

    allLinks = new Map();
    visited = new Set();
    linksToDiff = new Map();
    linkDiffs = new Map();
  }
  let branchDir = argv['branch-api-dir'] || path.join(__dirname, '..', 'dist', 'branch-api');
  let publishedDir = argv['base-api-dir'] || path.join(__dirname, '..', 'dist', 'base-api');
  if (mockFS) {
    branchDir = path.join(__dirname, '..', 'dist', 'branch');
    publishedDir = path.join(__dirname, '..', 'dist', 'base');
  }
  if (!(fs.existsSync(branchDir) && fs.existsSync(publishedDir))) {
    console.log(chalk.redBright(`you must have both a branchDir ${branchDir} and baseDir ${publishedDir}`));
    return;
  }

  if (!mockFS) {
    branchAPIs = fg.sync(`${branchDir}/**/api.json`);
    publishedAPIs = fg.sync(`${publishedDir}/**/api.json`);
  }
  let pairs = [];

  // find all matching pairs based on what's been published
  for (let pubApi of publishedAPIs) {
    // find closest package.json, use that as shared path
    let packageName = findPackageName(pubApi);
    let found = false;
    for (let branchApi of branchAPIs) {
      if (findPackageName(branchApi) === packageName) {
        found = true;
        pairs.push({pubApi, branchApi});
        break;
      }
    }
    if (!found) {
      pairs.push({pubApi, branchApi: null});
    }
  }

  // don't care about private APIs, but we do care if we're about to publish a new one
  for (let branchApi of branchAPIs) {
    let packageName = findPackageName(branchApi);
    let found = false;
    for (let pubApi of publishedAPIs) {
      if (findPackageName(pubApi) === packageName) {
        found = true;
        break;
      }
    }
    let pkgPath = path.join(branchApi, '..', '..', 'package.json');
    let json = JSON.parse(fs.readFileSync(pkgPath), 'utf8');
    if (!found && !json.private) {
      pairs.push({pubApi: null, branchApi});
    }
  }

  for (let branchApi of branchAPIs) {
    let api = JSON.parse(fs.readFileSync(branchApi), 'utf8');
    Object.entries(api.links).forEach(([key, value]) => {
      allLinks.set(key, value);
    });
  }
  for (let pubApi of publishedAPIs) {
    let api = JSON.parse(fs.readFileSync(pubApi), 'utf8');
    Object.entries(api.links).forEach(([key, value]) => {
      allLinks.set(key, value);
    });
  }

  let allDiffs = {};
  for (let pair of pairs) {
    let {diffs, name} = getDiff(pair, mockFS);
    if (diffs && diffs.length > 0) {
      allDiffs[name] = diffs;
    }
  }

  for (let [, diffs] of Object.entries(allDiffs)) {
    for (let {result: diff, simplifiedName} of diffs) {
      if (diff.length > 0) {
        if (!allChanged.has(simplifiedName)) {
          allChanged.set(simplifiedName, {result: diff, simplifiedName});
        }
      }
    }
  }

  let invertedDeps = invertDependencies();
  let messages = [];
  for (let [name, {result: diff, simplifiedName}] of allChanged.entries()) {
    let changes = [];
    let changedByDeps = followDependencies(simplifiedName);
    let affected = followInvertedDependencies(simplifiedName, invertedDeps);
    if (diff.length > 0) {
      let changedBy = changedByDeps.filter(dep => linkDiffs.get(dep).length > 0);
      // combine export change messages
      changes.push(`
#### ${mockFS ? simplifiedName : simplifiedName.split('packages/')[1]}
${changedBy.length > 0 ? `changed by:
- ${changedBy.join('\n - ')}\n\n` : ''}${diff.length > 0 ? diff : ''}${affected.length > 0 ? `
it changed:
- ${affected.join('\n - ')}
` : ''}
`);
    }
    if (changes.length > 0) {
      // combine the package change messages
      messages.push(`
  ### ${name.replace('/dist/api.json', '').replace(/^\//, '')}
  ${changes.join('\n')}
  -----------------------------------
  `
      );
    }
  }
  if (messages.length && !mockFS) {
    messages.forEach(message => {
      console.log(message);
    });
  } else if (messages.length) {
    await mockFS.writeFile(path.join(mockRoot, 'result.txt'), messages.join('\n\n'), {});
  }
}

// takes an interface name and follows all the interfaces dependencies to
// see if the interface changed as a result of a dependency changing
function followDependencies(iname) {
  let visited = new Set();
  let changedDeps = [];
  let exportName = iname;
  function visit(iname) {
    if (visited.has(iname)) {
      return;
    }
    visited.add(iname);
    let dependencies = dependantOnLinks.get(iname);
    if (dependencies && dependencies.length > 0) {
      for (let dep of dependencies) {
        if (linkDiffs.has(dep)) {
          changedDeps.push(dep);
        }
        visit(dep);
      }
    }
  }
  visit(exportName);
  return changedDeps;
}

function invertDependencies() {
  let changedUpstream = new Map();
  for (let [key, value] of dependantOnLinks.entries()) {
    for (let name of value) {
      if (changedUpstream.has(name)) {
        changedUpstream.get(name).push(key);
      } else {
        changedUpstream.set(name, [key]);
      }
    }
  }

  return changedUpstream;
}

// takes an interface name and follows all the interfaces dependencies to
// see if the interface changed as a result of a dependency changing
function followInvertedDependencies(iname, deps) {
  let visited = new Set();
  let affectedInterfaces = [];
  function visit(iname) {
    if (visited.has(iname)) {
      return;
    }
    visited.add(iname);
    if (deps.has(iname)) {
      let affected = deps.get(iname);
      if (affected && affected.length > 0) {
        for (let dep of affected) {
          affectedInterfaces.push(dep);
          visit(dep);
        }
      }
    }
  }
  visit(iname);
  return affectedInterfaces;
}

function getAPI(filePath) {
  let json = JSON.parse(fs.readFileSync(filePath), 'utf8');

  return json;
}

function condenseDiff(codeDiff, baseText, mockFS) {
  if (argv.verbose) {
    console.log(util.inspect(codeDiff, {depth: null}));
  }
  let result = [];
  let prevEnd = 1; // diff lines are 1 indexed
  let lines = (baseText ?? '').split('\n');
  codeDiff.hunks.forEach(hunk => {
    if (hunk.oldStart > prevEnd) {
      result = [...result, ...lines.slice(prevEnd - 1, hunk.oldStart - 1).map((item, index) => ` ${item}`)];
    }
    if (argv.isCI || mockFS) {
      result = [...result, ...hunk.lines];
    } else {
      result = [...result, ...hunk.lines.map(line => {
        if (line.startsWith('+')) {
          return chalk.whiteBright.bgGreen(line);
        } else if (line.startsWith('-')) {
          return chalk.whiteBright.bgRed(line);
        }
        return line;
      })];
    }
    prevEnd = hunk.oldStart + hunk.oldLines;
  });
  let joinedResult = '';
  if (codeDiff.hunks.length > 0) {
    joinedResult = [...result, ...lines.slice(prevEnd).map((item, index) => ` ${item}`)].join('\n');
  }
  return {joinedResult: joinedResult.replace(/\n.*No newline at end of file/, ''), result};
}

// bulk of the logic, read the api files, rebuild the interfaces, diff those reconstructions
function getDiff(pair, mockFS) {
  let name;
  if (pair.branchApi) {
    name = pair.branchApi.replace(/.*branch-api/, '');
  } else {
    name = pair.pubApi.replace(/.*published-api/, '');
  }

  if (argv.package && !argv.package.includes(name)) {
    return {diff: {}, name};
  }
  if (argv.verbose) {
    console.log(`diffing ${name}`);
  }
  let publishedApi = pair.pubApi === null ? {exports: {}, links: {}} : getAPI(pair.pubApi);
  let branchApi = pair.branchApi === null ? {exports: {}, links: {}} : getAPI(pair.branchApi);
  let publishedInterfaces = rebuildInterfaces(publishedApi);
  let branchInterfaces = rebuildInterfaces(branchApi);
  let formattedPublishedInterfaces = formatInterfaces(publishedInterfaces);
  let formattedBranchInterfaces = formatInterfaces(branchInterfaces);
  let allExportNames = new Map([...Object.entries(publishedApi.exports).map(([key, val]) => [key, val.id]), ...Object.entries(branchApi.exports).map(([key, val]) => [key, val.id])]);
  let allInterfaces = [...new Set([...Object.keys(formattedPublishedInterfaces), ...Object.keys(formattedBranchInterfaces)])];

  let diffs = [];

  let diffLinks = [...(linksToDiff.entries())];
  let pairLinks = [...diffLinks.reduce((acc, [key, value]) => {
    let pkg = key.replace(/(.*)(branch|base)\/(.*)/, '$3');
    let isBranch = key.includes('/branch/');
    if (acc.has(pkg)) {
      acc.set(pkg, {[isBranch ? 'branch' : 'base']: value, ...acc.get(pkg)});
    } else {
      acc.set(pkg, {[isBranch ? 'branch' : 'base']: value});
    }
    return acc;
  }, new Map()).entries()];
  pairLinks.forEach(([key, value]) => {
    let codeDiff = Diff.structuredPatch(key, key, value.base ?? '', value.branch ?? '', {newlineIsToken: true});
    let {joinedResult, result} = condenseDiff(codeDiff, value.base, mockFS);
    linkDiffs.set(key, joinedResult);
    diffs.push({result: joinedResult, simplifiedName: key});
  });

  allInterfaces.forEach((iname) => {
    if (argv.interface && argv.interface !== iname) {
      return;
    }
    let simplifiedName = allExportNames.get(iname).replace(/(.*)(branch|base)\/(.*)/, '$3');
    let codeDiff = Diff.structuredPatch(iname, iname, formattedPublishedInterfaces[iname] ?? '', formattedBranchInterfaces[iname] ?? '', {newlineIsToken: true});
    let {joinedResult, result} = condenseDiff(codeDiff, formattedPublishedInterfaces[iname], mockFS);

    if (argv.isCI && result.length > 0) {
      joinedResult = `\`\`\`diff
${joinedResult}
\`\`\``;
    }
    diffs.push({iname, result: joinedResult, simplifiedName});
  });

  return {diffs, name};
}

function processType(value) {
  let processed = visited.has(value);
  if (processed) {
    return '';
  }
  visited.add(value);
  let val = _processType(value);
  visited.delete(value);
  return val;
}

// mirrors dev/docs/src/types.js for the most part
// "rendering" our types to a string instead of React components
function _processType(value) {
  if (!value) {
    //console.trace('UNTYPED', value);
    return 'UNTYPED';
  }

  if (Object.keys(value).length === 0) {
    return '{}';
  }
  if (value.type === 'any') {
    return 'any';
  }
  if (value.type === 'null') {
    return 'null';
  }
  if (value.type === 'undefined') {
    return 'undefined';
  }
  if (value.type === 'void') {
    return 'void';
  }
  if (value.type === 'unknown') {
    return 'unknown';
  }
  if (value.type === 'never') {
    return 'never';
  }
  if (value.type === 'this') {
    return 'this';
  }
  if (value.type === 'symbol') {
    return 'symbol';
  }
  if (value.type === 'identifier') {
    return value.name;
  }
  if (value.type === 'string') {
    if (value.value) {
      return `'${value.value}'`;
    }
    return 'string';
  }
  if (value.type === 'number') {
    return 'number';
  }
  if (value.type === 'boolean') {
    return 'boolean';
  }
  if (value.type === 'union') {
    return value.elements.map(processType).join(' | ');
  }
  if (value.type === 'intersection') {
    return `(${value.types.map(processType).join(' & ')})`;
  }
  if (value.type === 'application') {
    let name = value.base.name;
    if (!name) {
      name = processType(value.base);
    }
    return `${name}<${value.typeParameters.map(processType).join(', ')}>`;
  }
  if (value.type === 'template') {
    return `\`${value.elements.map(element => element.type === 'string' ? element.value : `\${${processType(element)}}`).join('')}\``;
  }
  if (value.type === 'infer') {
    return `infer ${value.value}`;
  }
  if (value.type === 'typeOperator') {
    return `${value.operator} ${processType(value.value)}`;
  }
  if (value.type === 'function') {
    return `(${value.parameters.map(processType).join(', ')}) => ${value.return ? processType(value.return) : 'void'}`;
  }
  if (value.type === 'parameter') {
    return processType(value.value);
  }
  if (value.type === 'link' && value.id) {
    let type = allLinks.get(value.id);
    if (!type) {
      console.log(value.id, type);
    }
    if (!linksToDiff.has(value.id)) {
      let result = processType(type);
      linksToDiff.set(value.id, result);
    }
    let exportName = value.id.replace(/(.*)(branch|base)\/(.*)/, '$3');
    if (dependantOnLinks.has(currentlyProcessing)) {
      let allDeps = dependantOnLinks.get(currentlyProcessing);
      if (!allDeps.includes(exportName)) {
        allDeps.push(exportName);
      }
    } else {
      dependantOnLinks.set(currentlyProcessing, [exportName]);
    }
    return allLinks.get(value.id).name;
  }
  if (value.type === 'interface') {
    return `
interface ${value.name}${value.extends.length > 0 ? ` extends ${value.extends.map(processType).join(', ')}` : ''} {
${Object.values(value.properties).filter(property => property.access !== 'private' && property.access !== 'protected').map(property => {
  let result = ' '.repeat(depth);
  result = `${result}${property.indexType ? '[' : ''}${property.name}${property.indexType ? `: ${processType(property.indexType)}]` : ''}${property.optional ? '?' : ''}: ${processType(property.value)}`;
  return result;
}).join('\n')}
}
`;
  }
  // interface still needed if we have it at top level?
  if (value.type === 'object') {
    if (value.properties) {
      let result = `${value.exact ? '{\\' : '{'}
${Object.values(value.properties).map(property => {
  let result = ' '.repeat(depth);
  result = `${result}${property.indexType ? '[' : ''}${property.name}${property.indexType ? `: ${processType(property.indexType)}]` : ''}${property.optional ? '?' : ''}: ${processType(property.value)}`;
  return result;
}).join('\n')}
${value.exact ? '\\}' : `${' '.repeat(depth)}}`}`;
      return result;
    }
    return '{}';
  }
  if (value.type === 'alias') {
    return `type ${value.name} = {
  ${processType(value.value)}
}`;
  }
  if (value.type === 'mapped') {
    return `${value.readonly === '-' ? '-readonly' : ''}${processType(value.typeParameter)}: ${processType(value.typeAnnotation)}`;
  }
  if (value.type === 'array') {
    return `Array<${processType(value.elementType)}>`;
  }
  if (value.type === 'tuple') {
    return `[${value.elements.map(processType).join(', ')}]`;
  }
  if (value.type === 'typeParameter') {
    let typeParam = value.name;
    if (value.isMappedType && value.constraint) {
      typeParam = `[${typeParam} in ${processType(value.constraint)}]`;
    } else {
      if (value.constraint) {
        typeParam = typeParam + ` extends ${processType(value.constraint)}`;
      }
      if (value.default) {
        typeParam = typeParam + ` = ${processType(value.default)}`;
      }
    }
    return typeParam;
  }
  if (value.type === 'component') {
    let props = value.props;
    if (props.type === 'application') {
      props = props.base;
    }
    if (props.type === 'link') {
      // create links provider
      // props = links[props.id];
    }
    return processType(props);
  }
  if (value.type === 'conditional') {
    return `${processType(value.checkType)} extends ${processType(value.extendsType)} ? ${processType(value.trueType)}${value.falseType.type === 'conditional' ? ' :\n' : ' : '}${processType(value.falseType)}`;
  }
  if (value.type === 'indexedAccess') {
    return `${processType(value.objectType)}[${processType(value.indexType)}]`;
  }
  if (value.type === 'keyof') {
    return `keyof ${processType(value.keyof)}`;
  }
  if (value.type === 'variable') {
    return `${value.name}: ${processType(value.typeAnnotation)}`;
  }
  console.log('unknown type', value);
  return 'unknown type';
}

function rebuildInterfaces(json) {
  let exports = {};
  if (!json.exports) {
    console.log(json)
    return exports;
  }
  if (!json.links) {
    console.log(json)
  }

  [...(json.exports ? Object.keys(json.exports) : {}), ...(json.links ? Object.keys(json.links) : {})].forEach((key) => {
    let item = json.exports[key];
    if (item?.type == null) {
      // todo what to do here??
      return;
    }
    if (item.props?.type === 'identifier') {
      // todo what to do here??
      return;
    }
    if (!json.exports[key].id) {
      return;
    }
    currentlyProcessing = key.includes(':') ? key.replace(/(.*)(branch|base)\/(.*)/, '$3') : json.exports[key].id.replace(/(.*)(branch|base)\/(.*)/, '$3');
    if (item.type === 'component') {
      let compInterface = {};
      if (item.props && item.props.properties) {
        Object.entries(item.props.properties).sort((([keyA], [keyB]) => keyA > keyB ? 1 : -1)).forEach(([, prop]) => {
          if (prop.access === 'private') {
            return;
          }
          let name = prop.name;
          if (item.name === null) {
            name = key;
          }
          let optional = prop.optional;
          let defaultVal = prop.default;
          let value = processType(prop.value);
          compInterface[name] = {optional, defaultVal, value};
        });
      } else if (item.props && item.props.type === 'link') {
        let prop = item.props;
        let name = item.name;
        if (item.name === null) {
          name = key;
        }
        let optional = prop.optional;
        let defaultVal = prop.default;
        let value = processType(prop);
        compInterface[name] = {optional, defaultVal, value};
      }
      let name = item.name ?? key;
      if (item.typeParameters.length > 0) {
        name = name + `<${item.typeParameters.map(processType).join(', ')}>`;
      }
      exports[key] = {[name]: compInterface};
    } else if (item.type === 'function') {
      let funcInterface = {};
      Object.entries(item.parameters).forEach(([, param]) => {
        if (param.access === 'private') {
          return;
        }
        let name = param.name;
        let optional = param.optional;
        let defaultVal = param.default;
        let value = processType(param.value);
        funcInterface[name] = {optional, defaultVal, value};
      });
      let returnVal = processType(item.return);
      let name = item.name ?? key;
      if (item.typeParameters.length > 0) {
        name = name + `<${item.typeParameters.map(processType).join(', ')}>`;
      }
      exports[key] = {[name]: {...funcInterface, returnVal}};
    } else if (item.type === 'interface') {
      let funcInterface = {};
      Object.entries(item.properties).sort((([keyA], [keyB]) => keyA > keyB ? 1 : -1)).forEach(([, property]) => {
        if (property.access === 'private' || property.access === 'protected') {
          return;
        }
        let name = property.name;
        let optional = property.optional;
        let defaultVal = property.default;
        let value;
        if (property.value) {
          if (property.value.type === 'link' && !property.value.id) {
            console.log(item)
          }
          value = processType(property.value);
        }
        // TODO: what to do with defaultVal and optional
        funcInterface[name] = {optional, defaultVal, value};
      });
      let name = item.name ?? key;
      if (item.typeParameters.length > 0) {
        name = name + `<${item.typeParameters.map(processType).join(', ')}>`;
      }
      if (item.extends?.length > 0) {
        name = name + ` extends ${item.extends.map(processType).join(', ')}`;
      }
      exports[key] = {[name]: funcInterface};
    } else if (item.type === 'link') {
      let links = json.links;
      if (links[item.id]) {
        let link = links[item.id];

        let name = link.name;
        let optional = link.optional;
        let defaultVal = link.default;
        let value = processType(link.value);
        exports[key] = {[name]: {kind: 'type', optional, defaultVal, value}};
      }
    } else {
      let identifier = item;
      let value = processType(identifier);
      exports[key] = {[key]: {kind: 'identifier', value}};
    }
  });
  return exports;
}

function formatProp([name, prop]) {
  if (name === 'returnVal') {
    return `${name}: ${prop}`;
  }
  return `${name}${prop.optional ? '?' : ''}: ${prop.value}${prop.defaultVal != null ? ` = ${prop.defaultVal}` : ''}`;
}

function formatInterfaces(interfaces) {
  let result = {};
  Object.entries(interfaces).forEach(([id, value]) => {
    let [name, val] = Object.entries(value)[0];
    let output = '';
    if (val.kind === 'type') {
      output = `${name} {\n`;
      depth += 2;
      output += `${' '.repeat(depth)}${val.value}`;
      depth -= 2;
      result[id] = `${output}\n${' '.repeat(depth)}}\n`;
    } else if (val.kind === 'identifier') {
      output = val.value;
      result[id] = `${output}\n`;
    } else {
      output = `${name} {\n`;
      depth += 2;
      output += Object.entries(val).map(formatProp).map((prop) => `${' '.repeat(depth)}${prop}\n`).join('');
      depth -= 2;
      result[id] = `${output}${' '.repeat(depth)}}\n`;
    }
  });
  return result;
}
