import {VersionBadge} from '../../src/VersionBadge';
import {InstallCommand} from '../../src/InstallCommand';
import {Layout} from '../../src/Layout';
export default Layout;

import testUtilDocs from 'docs:@react-aria/test-utils';
import {InlineAlert, Heading, Content} from '@react-spectrum/s2'

export const section = 'Guides';
export const description = 'Writing tests for apps built with React Spectrum';

# Testing

<PageDescription>This page describes how to test an application built with React Spectrum. It documents the available testing utilities available for each aria pattern and how they can be used to simulate common user interactions.</PageDescription>

## Testing semantics

The recommended way to query for React Spectrum components and their internals is by semantics. React Spectrum
Components implement [ARIA patterns](https://www.w3.org/TR/wai-aria-practices-1.2/). ARIA is a W3C standard
that specifies the semantics for many UI components. Unlike the class names and DOM structure of the component, these
semantics are much less likely to change over time, making them ideal to query for.

The main attribute to look for when querying is the [role](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques).
This attribute represents the type of element a DOM node represents, e.g. a button, list option, or tab.

### React Testing Library

[React Testing Library](https://testing-library.com/docs/react-testing-library/intro) is useful because it
enforces that you write tests using semantics instead of implementation details. We use React Testing Library
to test React Spectrum itself, and it's quite easy to [query](https://testing-library.com/docs/dom-testing-library/api-queries)
elements by role, text, label, etc.

```tsx
import {render} from '@testing-library/react';

let tree = render(<MyComponent />);
let option = tree.getByRole('button');
```

## Test ids

Querying by semantics covers many scenarios, but what if you have many buttons on a page or its text changes due to translations based on locale?
In these cases, you may need a way to identify specific elements in tests, and that's where test ids come in.

React Spectrum components pass all [data attributes](https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes)
through to their underlying DOM nodes, which allows you to use an attribute like `data-testid` to identify
a particular instance of a component.

```tsx
import {render} from '@testing-library/react';
import {TextField} from '@react-spectrum/s2';

function LoginForm() {
  return (
    <>
      <TextField label="Username" data-testid="username" />
      <TextField label="Password" data-testid="password" />
    </>
  );
}

let tree = render(<LoginForm />);
let username = tree.getByTestId('username');
let password = tree.getByTestId('password');
```

## Triggering events

React Spectrum components rely on many different browser events to support different devices and platforms, so it's important to simulate
these correctly in your tests. For example, a click is really a `mousemove` and `mouseover` the target, followed
by `mousedown`, `focus`, and `mouseup` events, and finally a `click` event.

The best way to handle this is with the [user-event](https://github.com/testing-library/user-event) library.
This lets you trigger high level interactions like a user would, and the library handles firing all of the individual
events that make up that interaction.

```tsx
import {render} from '@testing-library/react';
import userEvent from '@testing-library/user-event';

let tree = render(<LoginForm />);

// Click on the username field to focus it, and enter the value.
userEvent.click(tree.getByLabelText('Username'));
userEvent.type(document.activeElement, 'devon');

// Tab to the password field, and enter the value.
userEvent.tab();
userEvent.type(document.activeElement, 'Pas$w0rd');

// Tab to the submit button and click it.
userEvent.tab();
userEvent.click(document.activeElement);
```

## Test setup and common gotchas

### Timers

If you are using fake timers in your test suite, be aware that you may need to advance your timers after various interactions. We have `requestAnimationFrame` calls in various underlying hooks that you will need to also handle by advancing your timers in the tests.
This happens most prominently in our collection components after selection. In Jest, this can be handled by calling `act(() => jest.runAllTimers());` but you may require more precise control
depending on the other time-sensitive behavior you are testing. Please see [Jest's timer docs](https://jestjs.io/docs/timer-mocks) or the equivalent docs of your test frameworks for more information on how to do so.
It is also a good idea to run all timers to completion after each test case to avoid any left over transitions or timeouts that a component may have setup during its lifecycle.

```tsx
afterEach(() => {
  act(() => jest.runAllTimers());
});
```

Consider adding a `act(() => jest.runAllTimers());` after your simulated user interaction if you run into a test failure that looks like the following:

```
TestingLibraryElementError: Unable to find an accessible element with the role "listbox"
```

If you are using real timers instead, you can await a particular state of your app to be reached. If you are using React Testing Library, you can perform a `waitFor` query
to wait for a dialog to appear:

```tsx
await waitFor(() => {
  expect(getByRole('dialog')).toBeInTheDocument();
});
```

### Simulating user long press

Some components like Menu support long press operations. Unfortunately, the approach of using the userEvent library to simulate a press event and running timers to hit the
long press internal timer threshold isn't sufficient due to `useLongPress`'s usage of `PointerEvent` and our own detection of `virtual` vs `mouse`/`touch` pointer types. Mock [PointerEvent](https://github.com/adobe/react-spectrum/blob/16ff0efac57eebeb1cd601ab376ce7c58a4e4efd/packages/dev/test-utils/src/events.ts#L70-L103)
globally and use `fireEvent` from `@testing-library/react` to properly simulate these long press events in your tests.
If you are using Jest, you can call our <TypeLink links={testUtilDocs.links} type={testUtilDocs.exports.installPointerEvent} /> utility to automatically set up and tear down this mock in your test.
Additionally, if you are using fake timers and don't need to control the specific timings around the long press interaction, feel free to use our <TypeLink links={testUtilDocs.links} type={testUtilDocs.exports.triggerLongPress} /> utility as shown below.

```tsx
import {fireEvent} from '@testing-library/react';
import {installPointerEvent, triggerLongPress} from '@react-spectrum/test-utils';
installPointerEvent();

// In test case
let button = getByRole('button');

// With fireEvent and specific timing control
fireEvent.pointerDown(el, {pointerType: 'touch'});
act(() => jest.advanceTimersByTime(800));
fireEvent.up(el, {pointerType: 'touch'});

// With triggerLongPress
triggerLongPress(button);
```

### Simulating move event

Components like ColorArea, ColorSlider, ColorWheel, and Slider each feature a draggable handle that a user can interact with to change the component's value. Similar to long press, the interactions offered by userEvent library aren't sufficient to trigger
the underlying event handlers governing these drag/move operations. [Mock MouseEvent globally](https://github.com/adobe/react-spectrum/blob/16ff0efac57eebeb1cd601ab376ce7c58a4e4efd/packages/dev/test-utils/src/events.ts#L44-L68) and `fireEvent` from `@testing-library/react` to simulate these drag/move events in your tests.
If you are using Jest, you can call our <TypeLink links={testUtilDocs.links} type={testUtilDocs.exports.installMouseEvent} /> utility to automatically set up and tear down this mock in your test. Additionally, the track dimensions
for the draggable handle should be mocked so that the move operation calculations can be properly computed.

```tsx
import {fireEvent} from '@testing-library/react';
import {installMouseEvent} from '@react-spectrum/test-utils';
installMouseEvent();

beforeAll(() => {
  jest.spyOn(window.HTMLElement.prototype, 'getBoundingClientRect').mockImplementation(() => ({top: 0, left: 0, width: 100, height: 10}));
})

// In test case
let sliderThumb = getByRole('slider').parentElement;

// With fireEvent, move thumb from 0 to 50
fireEvent.mouseDown(thumb, {clientX: 0, pageX: 0});
fireEvent.mouseMove(thumb, {pageX: 50});
fireEvent.mouseUp(thumb, {pageX: 50});
```

## React Spectrum test utils

TODO can't place this next to the header here
<VersionBadge version="beta" />

In addition to the test utilities mentioned above, [@react-spectrum/test-utils](https://www.npmjs.com/package/@react-spectrum/test-utils) re-exports the same test utils available in `@react-aria/test-utils`, including
the ARIA pattern testers. These testers are set of testing utilities that aims to make writing unit tests easier for consumers of React Spectrum.

### Installation

<InstallCommand pkg="@react-spectrum/test-utils" flags="--dev" />

<InlineAlert variant="notice">
  <Heading>Requirements</Heading>
  <Content>Please note that this library uses [@testing-library/react@16](https://www.npmjs.com/package/@testing-library/react) and [@testing-library/user-event@14](https://www.npmjs.com/package/@testing-library/user-event). This means that you need to be on React 18+ in order for these utilities to work.</Content>
</InlineAlert>


### Setup

Once installed, you can access the `User` that `@react-spectrum/test-utils` provides in your test file as shown below. This user only needs to be initialized once and then can be used to generate
specific ARIA pattern tester in your test cases. This gives you access to that pattern's specific utilities that you can then call within your test to query for specific subcomponents or simulate common interactions.
See [below](#patterns) for what patterns are currently supported.

```ts
// YourTest.test.ts
import {screen} from '@testing-library/react';
import {User} from '@react-spectrum/test-utils';

// Provide whatever method of advancing timers you use in your test, this example assumes Jest with fake timers.
// 'interactionType' specifies what mode of interaction should be simulated by the tester
// 'advanceTimer' is used by the tester to advance the timers in the tests for specific interactions (e.g. long press)
let testUtilUser = new User({interactionType: 'mouse', advanceTimer: jest.advanceTimersByTime});
// ...

it('my test case', async function () {
  // Render your test component/app
  render();
  // Initialize the table tester via providing the 'Table' pattern name and the root element of said table
  let table = testUtilUser.createTester('Table', {root: screen.getByTestId('test_table')});

  // ...
});
```

See below for the full definition of the `User` object.

<ClassAPI links={testUtilDocs.links} class={testUtilDocs.exports.User} />

### Patterns

<ExampleSwitcher type={null} examples={['CheckboxGroup', 'ComboBox', 'Dialog', 'Menu', 'Picker', 'RadioGroup', 'TableView', 'Tabs', 'TreeView']}>

<>
  ```ts isInSwitcher
  // CheckboxGroup.test.ts
  import {render} from '@testing-library/react';
  import {User} from '@react-spectrum/test-utils';

  let testUtilUser = new User({interactionType: 'mouse', advanceTimer: jest.advanceTimersByTime});
  // ...

  it('CheckboxGroup can select multiple checkboxes', async function () {
    // Render your test component/app and initialize the checkbox group tester
    let {getByTestId} = render(
      <CheckboxGroup data-testid="test-checkboxgroup">
      ...
      </CheckboxGroup>
    );
    let checkboxGroupTester = testUtilUser.createTester('CheckboxGroup', {root: getByTestId('test-checkboxgroup')});
    expect(checkboxGroupTester.selectedCheckboxes).toHaveLength(0);

    await checkboxGroupTester.toggleCheckbox({checkbox: 0});
    expect(checkboxGroupTester.checkboxes[0]).toBeChecked();
    expect(checkboxGroupTester.selectedCheckboxes).toHaveLength(1);

    await checkboxGroupTester.toggleCheckbox({checkbox: 4});
    expect(checkboxGroupTester.checkboxes[4]).toBeChecked();
    expect(checkboxGroupTester.selectedCheckboxes).toHaveLength(2);
  });
  ```
  <ClassAPI links={testUtilDocs.links} class={testUtilDocs.exports.CheckboxGroupTester} isInSwitcher />
</>

<>
  ```ts isInSwitcher
  // Combobox.test.ts
  import {render} from '@testing-library/react';
  import {User} from '@react-spectrum/test-utils';

  let testUtilUser = new User({interactionType: 'mouse'});
  // ...

  it('ComboBox can select an option via keyboard', async function () {
    // Render your test component/app and initialize the combobox tester
    let {getByTestId} = render(
      <ComboBox data-testid="test-combobox">
        ...
      </ComboBox>
    );
    let comboboxTester = testUtilUser.createTester('ComboBox', {root: getByTestId('test-combobox'), interactionType: 'keyboard'});

    await comboboxTester.open();
    expect(comboboxTester.listbox).toBeInTheDocument();

    let options = comboboxTester.options();
    await comboboxTester.selectOption({option: options[0]});
    expect(comboboxTester.combobox.value).toBe('One');
    expect(comboboxTester.listbox).not.toBeInTheDocument();
  });
  ```
  <ClassAPI links={testUtilDocs.links} class={testUtilDocs.exports.ComboBoxTester} isInSwitcher />
</>

<>
  ```ts isInSwitcher
  // Dialog.test.ts
  import {render} from '@testing-library/react';
  import {User} from '@react-spectrum/test-utils';

  let testUtilUser = new User({interactionType: 'mouse', advanceTimer: jest.advanceTimersByTime});
  // ...

  it('Dialog can be opened and closed', async function () {
    // Render your test component/app and initialize the dialog tester
    let {getByTestId, getByRole} = render(
      <DialogTrigger>
        <ActionButton>Trigger</ActionButton>
        <Dialog>
          ...
        </Dialog>
      </DialogTrigger>
    );
    let button = getByRole('button');
    let dialogTester = testUtilUser.createTester('Dialog', {root: button, overlayType: 'modal'});
    await dialogTester.open();
    let dialog = dialogTester.dialog;
    expect(dialog).toBeVisible();
    await dialogTester.close();
    expect(dialog).not.toBeInTheDocument();
  });
  ```
  <ClassAPI links={testUtilDocs.links} class={testUtilDocs.exports.DialogTester} isInSwitcher />
</>

<>
  ```ts isInSwitcher
  // Menu.test.ts
  import {render} from '@testing-library/react';
  import {User} from '@react-spectrum/test-utils';

  let testUtilUser = new User({interactionType: 'mouse'});
  // ...

  it('Menu can open its submenu via keyboard', async function () {
    // Render your test component/app and initialize the menu tester
    let {getByTestId} = render(
      <MenuTrigger>
        <Button data-testid="test-menutrigger">Menu trigger</Button>
        ...
      </MenuTrigger>
    );
    let menuTester = testUtilUser.createTester('Menu', {root: getByTestId('test-menutrigger'), interactionType: 'keyboard'});

    await menuTester.open();
    expect(menuTester.menu).toBeInTheDocument();
    let submenuTriggers = menuTester.submenuTriggers;
    expect(submenuTriggers).toHaveLength(1);

    let submenuTester = await menuTester.openSubmenu({submenuTrigger: 'Share…'});
    expect(submenuTester.menu).toBeInTheDocument();

    await submenuTester.selectOption({option: submenuTester.options()[0]});
    expect(submenuTester.menu).not.toBeInTheDocument();
    expect(menuTester.menu).not.toBeInTheDocument();
  });
  ```
  <ClassAPI links={testUtilDocs.links} class={testUtilDocs.exports.MenuTester} isInSwitcher />
</>

<>
  ```ts isInSwitcher
  // Picker.test.ts
  import {render} from '@testing-library/react';
  import {User} from '@react-spectrum/test-utils';

  let testUtilUser = new User({interactionType: 'mouse'});
  // ...

  it('Picker can select an option via keyboard', async function () {
    // Render your test component/app and initialize the select tester
    let {getByTestId} = render(
      <Picker data-testid="test-select">
      ...
      </Picker>
    );
    let selectTester = testUtilUser.createTester('Select', {root: getByTestId('test-select'), interactionType: 'keyboard'});
    let trigger = selectTester.trigger;
    expect(trigger).toHaveTextContent('Select an item');

    await selectTester.selectOption({option: 'Cat'});
    expect(trigger).toHaveTextContent('Cat');
  });
  ```
  <ClassAPI links={testUtilDocs.links} class={testUtilDocs.exports.SelectTester} isInSwitcher />
</>

<>
  ```ts isInSwitcher
  // RadioGroup.test.ts
  import {render} from '@testing-library/react';
  import {User} from '@react-spectrum/test-utils';

  let testUtilUser = new User({interactionType: 'mouse', advanceTimer: jest.advanceTimersByTime});
  // ...

  it('RadioGroup can switch the selected radio', async function () {
    // Render your test component/app and initialize the radiogroup tester
    let {getByRole} = render(
      <RadioGroup>
        ...
      </RadioGroup>
    );

    let radioGroupTester = testUtilUser.createTester('RadioGroup', {root: getByRole('radiogroup')});
    let radios = radioGroupTester.radios;
    expect(radioGroupTester.selectedRadio).toBeFalsy();

    await radioGroupTester.triggerRadio({radio: radios[0]});
    expect(radioGroupTester.selectedRadio).toBe(radios[0]);

    await radioGroupTester.triggerRadio({radio: radios[1]});
    expect(radioGroupTester.selectedRadio).toBe(radios[1]);
  });
  ```
  <ClassAPI links={testUtilDocs.links} class={testUtilDocs.exports.RadioGroupTester} isInSwitcher />
</>

<>
  ```ts isInSwitcher
  // Table.test.ts
  import {render, within} from '@testing-library/react';
  import {User} from '@react-spectrum/test-utils';

  let testUtilUser = new User({interactionType: 'mouse', advanceTimer: jest.advanceTimersByTime});
  // ...

  it('TableView can toggle row selection', async function () {
    // Render your test component/app and initialize the table tester
    let {getByTestId} = render(
      <TableView data-testid="test-table" selectionMode="multiple">
      ...
      </TableView>
    );
    let tableTester = testUtilUser.createTester('Table', {root: getByTestId('test-table')});
    expect(tableTester.selectedRows).toHaveLength(0);

    await tableTester.toggleSelectAll();
    expect(tableTester.selectedRows).toHaveLength(10);

    await tableTester.toggleRowSelection({row: 2});
    expect(tableTester.selectedRows).toHaveLength(9);
    let checkbox = within(tableTester.rows[2]).getByRole('checkbox');
    expect(checkbox).not.toBeChecked();

    await tableTester.toggleSelectAll();
    expect(tableTester.selectedRows).toHaveLength(10);
    expect(checkbox).toBeChecked();

    await tableTester.toggleSelectAll();
    expect(tableTester.selectedRows).toHaveLength(0);
  });
  ```
  <ClassAPI links={testUtilDocs.links} class={testUtilDocs.exports.TableTester} isInSwitcher />
</>

<>
  ```ts isInSwitcher
  // Tabs.test.ts
  import {render} from '@testing-library/react';
  import {User} from '@react-spectrum/test-utils';

  let testUtilUser = new User({interactionType: 'mouse'});
  // ...

  it('Tabs can change selection via keyboard', async function () {
    // Render your test component/app and initialize the listbox tester
    let {getByTestId} = render(
      <Tabs data-testid="test-tabs">
        ...
      </Tabs>
    );
    let tabsTester = testUtilUser.createTester('Tabs', {root: getByTestId('test-tabs'), interactionType: 'keyboard'});

    let tabs = tabsTester.tabs;
    expect(tabsTester.selectedTab).toBe(tabs[0]);

    await tabsTester.triggerTab({tab: 1});
    expect(tabsTester.selectedTab).toBe(tabs[1]);
  });
  ```
  <ClassAPI links={testUtilDocs.links} class={testUtilDocs.exports.TabsTester} isInSwitcher />
</>

<>
  ```ts isInSwitcher
  // Tree.test.ts
  import {render, within} from '@testing-library/react';
  import {User} from '@react-spectrum/test-utils';

  let testUtilUser = new User({interactionType: 'mouse'});
  // ...

  it('TreeView can select a item via keyboard', async function () {
    // Render your test component/app and initialize the Tree tester
    let {getByTestId} = render(
      <Tree data-testid="test-tree" selectionMode="multiple">
        ...
      </Tree>
    );
    let treeTester = testUtilUser.createTester('Tree', {root: getByTestId('test-tree'), interactionType: 'keyboard'});

    await treeTester.toggleRowSelection({row: 0});
    expect(treeTester.selectedRows).toHaveLength(1);
    expect(within(treeTester.rows[0]).getByRole('checkbox')).toBeChecked();

    await treeTester.toggleRowSelection({row: 1});
    expect(treeTester.selectedRows).toHaveLength(2);
    expect(within(treeTester.rows[1]).getByRole('checkbox')).toBeChecked();

    await treeTester.toggleRowSelection({row: 0});
    expect(treeTester.selectedRows).toHaveLength(1);
    expect(within(treeTester.rows[0]).getByRole('checkbox')).not.toBeChecked();
  });
  ```
  <ClassAPI links={testUtilDocs.links} class={testUtilDocs.exports.TreeTester} isInSwitcher />
</>

</ExampleSwitcher>
